<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>TS Pres</title>

	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/monokai.css">


	<style>
		.dense-font {
			font-size: 0.75em;
		}

		.js {
			max-width: 50px;
			background: #f7df1e;
			padding: 24px 8px 2px 24px;
			color: black;
			font-family: sans-serif;
			font-weight: bold;
		}

		.ts {
			max-width: 50px;
			background: #007acc;
			padding: 24px 8px 2px 24px;
			color: white;
			font-family: sans-serif;
			font-weight: bold;
		}

		.langed-snipped {
			display: flex;
			flex-flow: column nowrap;
			justify-content: center;
		}

		.langed-snipped pre {
			margin: 0;
		}

		.flash-green-bg {
			background: greenyellow;
		}

		#RevealLuckyNumberType-Code {
			font-size: 2em;
			overflow: visible;
		}

		.hljs {
			overflow: hidden !important;
		}


		.ts-diagram-wrapper {
			position: relative;
		}

		.jsCircle {
			position: absolute;
			left: calc(50% - 150px);
			top: 0;
			color: black;
			background-color: #f7df1e;
			width: 300px;
			height: 300px;
			border-radius: 300px;
			display: flex;
			flex-flow: row nowrap;
			justify-content: center;
			align-items: center;
		}

		.tsCircle {
			position: absolute;
			left: calc(50% - 150px);
			top: 0;
			color: black;
			background-color: #007acc;
			color: white;
			z-index: -1;
			width: 500px;
			height: 500px;
			border-radius: 500px;
			display: flex;
			flex-flow: row nowrap;
			justify-content: center;
			align-items: center;
		}
	</style>

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section></section>
			<section data-transition="slide" data-background="#007acc" data-background-transition="zoom">
				<h1>Typescript</h1>
				<h2>w 30 minut <span class="fragment">(+/-)</span></h2>
			</section>
			<section>
				<h2>Czym jest typescript?</h2>
				<div class="ts-diagram-wrapper fragment">
					<div class="jsCircle" style="transform: translate3d(26px, 32px, 0)">Javascript</div>
					<div class="tsCircle fragment"><span style="transform: translate3d(42px,120px,0)">Typescript</span>
					</div>
				</div>
			</section>
			<section>
				<h2>Deklaracja zmiennej</h2>
				<div class="fragment langed-snipped">
					<span class="js">JS</span>
					<pre>
						<code class="hljs javascript">let helllo = 'world';</code>
					</pre>
				</div>
				<div class="fragment langed-snipped">
					<span class="ts">TS</span>
					<pre>
						<code class="hljs typescript">let helllo: string = 'world';</code>
						<code class="hljs typescript fragment">
const PI: number = 3.14;
var maybeTrueMaybeFalse: boolean = Math.random() > 0.5;
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h2>Typy Singletonowe</h2>
				<div>
					<pre>
					<code class="hljs typescript" id="RevealLuckyNumberType-Code">let luckyNumber = 4;</code>
				</pre>
				</div>
				<p class="fragment" data-show-event="RevealLuckyNumberType">
				</p>
				<p class="fragment">
					<img src="img/singletonTypErr.png" />
				</p>
				<pre class="fragment">
					<code class="hljs typescript">
const immaString: 'immaString' = 'immaString';
const alwaysTrue: true = true;
					</code>
				</pre>
			</section>
			<section>
				<h2>Tablice</h2>
				<pre class="fragment">
						<code class="hljs typescript" >const ages: number[] = [27, 25];
const names: string[] = ['John', 'Jaine'];
						</code>
					</pre>
			</section>
			<section>
				<h2>Tablice - jako pary (tuple)</h2>
				<pre class="fragment">
							<code class="hljs typescript">
const weightNamePair: [number, string]  = [27, 'John'];
							</code>
						</pre>
				<div class="fragment">
					<p>Możemy łączyć tablicę oraz "tuple"</p>
					<pre>
								<code class="hljs typescript" style="overflow:  hidden">
const weightNamePairs: [number, string][] = [
	[27, 'John'],
	[25, 'Jaine']
];
								</code>
							</pre>
				</div>
			</section>
			<section>
				<h2>Typ - <span class="hljs-name" style="text-transform: lowercase">any</span></h2>
				<p>
					<span class="hljs-name" style="text-transform: lowercase">any</span> to specjalny typ do którego
					możemy przypisać <strong>dowolną</strong> wartość.
				</p>
				<div class="fragment">
					<pre>
									<code class="hljs typescript" style="overflow:  hidden">
let anyhingYouWant: any = true;
anyhingYouWant = null;
anyhingYouWant = 'BRAH!';
									</code>
						</pre>

				</div>
				<p class="fragment">Pozwala na "wyłączenie" sprawdzania typów. Przydatne gdy nie potrafimy wyrazić
					jakiegoś typu lub
					po prostu eksperymentujemy.</p>
			</section>
			<section>
				<h2 class="dense-font">Typ - <span class="hljs-name" style="text-transform: lowercase">never</span></h2>
				<p class="dense-font">
					<span class="hljs-name" style="text-transform: lowercase">never</span> to specjalny typ do którego
					nie możemy przypisać <strong style="text-decoration: underline">żadnej</strong> wartości
				</p>
				<img class="fragment" src="img/never-assing.png" />
				<p class="fragment dense-font">Symbolizuje wartość która nigdy nie istnieje.
					Byłby to np. typ zwracany z funkcji która nigdy się nie powodzi lub nigdy się nie kończy
					np. funkcja która wykonuję: while(<span class="hljs-name">true</span>){}
				</p>
			</section>


			<section>
				<h2>Inferencja typów</h2>
				<p class="fragment dense-font">Wypisywanie ciągle tych typów po dwukroku wygląda męcząco...</p>
				<p class="fragment dense-font">...naszczęście w sporej ilości przypadków Typescript jest w stanie samemu
					wydedukować sobie typ z kontesktu naszego programu.</p>
				<img src="img/infer_demo.png" class="fragment" />
			</section>

			<section>
				<h2 class="font-dense">Typowanie funkcji</h2>
				<div class="langed-snipped">
					<span class="js">JS</span>
					<pre>
							<code class="hljs javascript">function add(a, b) {
  return a + b;
}

</code>
						</pre>
					<div class="fragment">
						<p style="text-align: left">Wywołanie</p>
						<pre>
								<code class="hljs javascript">add(3,5); // => 8
add([], '?????'); // => "??"</code>
					</pre>
					</div>

				</div>
			</section>
			<section>
				<h2 class="font-dense">Typowanie funkcji</h2>
				<div class="langed-snipped">
					<span class="ts">TS</span>
					<pre>
								<code class="hljs javascript">function add(a: number, b:number): number {
  return a + b;
}</code>
							</pre>
					<div class="fragment">
						<p style="text-align: left">Wywołanie</p>
						<pre>
									<code class="hljs javascript">add(3,5); // => 8
add([], '???'); // błąd
	</code>
								</pre>
					</div>
				</div>
			</section>


			<section>
				<h2>Typowanie obiektów</h2>
			</section>

			<section>
				<h2>Interfejs
					y</h2>
				<pre>
						<code class="hljs typescript">interface IPerson {
	name: string;
	age: number;
	sayHi(): void;
}</code>
			</pre>
				<p>
					Deklarują <strong>kształt</strong> danego obiektu. Mogą zawierać pola jak i metody.
				</p>
			</section>

			<section>
				<h2>Interfejsy - użycie</h2>
				<p class="dense-font">W przeciwieństwie do innych języków programowania nie musimy interfejsów
					implementować.
					Możemy stworzyć <i>ad-hoc</i> implemetancje danego interfejsu </p>
				<pre>
						<code class="hljs typescript" style="overflow: hidden">const me: IPerson = { 
  name: 'Dawid',
  age: 24,
  sayHi() {
    console.log('hi!');
  }							
}</code>
			</section>

			<section>
				<h2>Klasy</h2>
				<pre>
							<code class="hljs typescript">
class Student implements IPerson {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  sayHi() {
    console.log(`Imma ${this.name}!~~`);
  }
}</code>
				</pre>
			</section>
			<section>
				<h2>Klasy</h2>
				<pre>
								<code class="hljs typescript" data-trim data-noescape>
	class Student implements <mark>IPerson</mark> {
	  name: string;
	  age: number;
	
	  constructor(name: string, age: number) {
		this.name = name;
		this.age = age;
	  }
	
	  sayHi() {
		console.log(`Imma ${this.name}!~~`);
	  }
	}</code>
					</pre>
			</section>
			<section>
				<h2>Klasy</h2>
				<pre>
									<code class="hljs typescript" data-trim data-noescape>
		class Student implements IPerson {<mark>
		  name: string;
		  age: number;</mark>
		
		  constructor(name: string, age: number) {
			this.name = name;
			this.age = age;
		  }
		
		  sayHi() {
			console.log(`Imma ${this.name}!~~`);
		  }
		}</code>
						</pre>
			</section>
			<section>
				<h2>Zieeeew</h2>
				<h3>Czy to kolejna <strike>Java</strike>/C# ?</h3>
				<img src="img/thinking.png" style="max-height: 220px" />
				<p class="fragment">
					Odpowiedź brzmiałaby <strong class="hljs-name">tak</strong> gdyby nie typescript ~ 2.1
				</p>
			</section>
			<section>
				<h2>Zaanwansowane typy danych</h2>
			</section>
			<section>
				<div class="langed-snipped">
					<span class="js">JS</span>
					<pre>
									<code class="hljs javascript">padLeft("world", 4) === "    world";
padLeft("world", "hello ") === "hello world"</code>
							</pre>
				</div>
			</section>
			<section>
				<div class="langed-snipped">
					<span class="js">JS</span>
					<pre>
								<code class="hljs javascript" data-line-numbers="2">
function padLeft(value, padding) {
	if (typeof padding === "string") {
		return padding + value;
	}
	if (typeof padding === "number") {
		return Array(padding + 1).join(" ") 
			+ value;
	}
	throw new Error(`Expected string or
		 number, got '${padding}'.`);
}
								</code>
						</pre>
				</div>
			</section>
			<section>
				<div class="langed-snipped">
					<span class="js">JS</span>
					<pre>
									<code class="hljs javascript"  data-line-numbers="3-5">
function padLeft(value, padding) {
	if (typeof padding === "string") {
		return padding + value;
	}
	if (typeof padding === "number") {
		return Array(padding + 1).join(" ") 
			+ value;
	}
	throw new Error(`Expected string or
			number, got '${padding}'.`);
}
									</code>
							</pre>
				</div>
			</section>
			<section>
				<div class="langed-snipped">
					<span class="js">JS</span>
					<pre>
										<code class="hljs javascript"  data-line-numbers="5-9">
function padLeft(value, padding) {
	if (typeof padding === "string") {
		return padding + value;
	}
	if (typeof padding === "number") {
		return Array(padding + 1).join(" ") 
			+ value;
	}
	throw new Error(`Expected string or
			number, got '${padding}'.`);
}
										</code>
								</pre>
				</div>
			</section>
			<section>
				<div class="langed-snipped">
					<span class="js">JS</span>
					<pre>
											<code class="hljs javascript"  data-line-numbers="10-11">
function padLeft(value, padding) {
	if (typeof padding === "string") {
		return padding + value;
	}
	if (typeof padding === "number") {
		return Array(padding + 1).join(" ") 
			+ value;
	}
	throw new Error(`Expected string or
			number, got '${padding}'.`);
}
											</code>
									</pre>
				</div>
			</section>
			<section>
				<div class="langed-snipped">
					<span class="ts">TS</span>
					<pre>
													<code class="hljs typescript">
function padLeft(value: string, padding: ???): string {
													</code>
					</pre>
					<p style="text-align: left">hierarchia klas, any?</p>
					<div class="fragment">
						<p style="text-align: left">unie!</p>
						<pre>
								<code class="hljs javascript" data-trim data-noescape>
function padLeft(value: string, padding: <mark>string | number</mark>)
	: string {
								</code>
</pre>
					</div>
				</div>
			</section>

			<section>
				<h2>Unie</h2>
				<img src="img/union_types.png" />
			</section>

			<section>
				<h2>Strażniki typu</h2>
				<p>(type guards)</p>
				<img src="img/type_guards.png" />
			</section>

			<section>
				<h2>Strażniki typu</h2>
				<p>w akcji</p>
				<img src="img/type_guards_in_action.png" />
			</section>

			<section>
				<h2>Aliasy typów</h2>
				<p>Pozwalają nadać alternatywną nazwę innemu typowi</p>
				<p><span class="hljs-name">type</span> AlternatywnaNazwa = InnyTyp;</p>
				<img src="img/aliasing.png" class="fragment" />
			</section>

			<section>
				<h2>Aliasy typów</h2>
				<p>Szczególnie przydatne jeżeli używamy uni</p>
				<img src="img/aliasing_inaction.png" />
			</section>

			<section>
				<h2>Poznaliśmy</h2>
				<ul>
					<li>Interfejsy</li>
					<li class="fragment">Unię</li>
					<li class="fragment">Strażniki typów</li>
					<li class="fragment">Aliasy</li>
				</ul>
				<p class="fragment">Zobaczmy co się stanie gdy połączymy je razem! 🔥</p>
			</section>

			<section>
				<p>Zadeklarujmy kilka interfejsów</p>
				<img src="img/ifaces.png" />
			</section>

			<section>
				<img src="img/shapealias.png" />
				<img class="fragment" src="img/shapes.png" />
			</section>
			<section>
				<h2>Możemy teraz budować abstrakcje na tym <i
						style="font-style: italic; text-decoration: underline">zamkniętym</i> zbiorze typów</h2>
			</section>
			<section>
				<pre>
							<code class="hljs javascript" data-trim data-noescape data-line-numbers="1">
								function area(shape: Shape):  number {
							</code>
					</pre>
				<p><span class="hljs-variable">area</span> zwróci nam pole dla danego <span
						class="hljs-name">Shape</span></p>
			</section>
			<section>
				<pre>
					<code class="hljs javascript" data-trim data-noescape data-line-numbers="2">
						function area(s: Shape): number {
							switch (s.kind) {
								case "square":
									return s.size ** 2;
								case "rectangle":
									return s.height * s.width;
								case "circle":
									return Math.PI * s.radius ** 2;
								default:
									throw new Error(`Expected Shape, got ${s}`);
							}
						}
					</code>
				</pre>
				<p>Pierw zobaczmy z czym mamy do czynienia. Wcześniej nadany tag się tutaj przydaje!</p>
			</section>
			<section>
				<pre>
					<code class="hljs javascript" data-trim data-noescape data-line-numbers="3-4">
						function area(s: Shape): number {
							switch (s.kind) {
								case "square":
									return s.size ** 2;
								case "rectangle":
									return s.height * s.width;
								case "circle":
									return Math.PI * s.radius ** 2;
								default:
									throw new Error(`Unexpected obj:${s}`);
								}
						}	
						</code>
				</pre>
				<p>Dla kwadratu weźmiemy długość jego boku</p>
				<p class="fragment">(** - operator podnoszenia do potęgi)</p>
			</section>

			<section>
				<pre>
					<code class="hljs javascript" data-trim data-noescape data-line-numbers="5-8">
						function area(s: Shape): number {
							switch (s.kind) {
								case "square":
									return s.size ** 2;
								case "rectangle":
									return s.height * s.width;
								case "circle":
									return Math.PI * s.radius ** 2;
								default:
									throw new Error(`Unexpected obj:${s}`);
							}
						}	
						</code>
				</pre>
				<p>Analogicznie postępujemy dla innych tagów</p>
			</section>

			<section>
				<pre>
					<code class="hljs javascript" data-trim data-noescape data-line-numbers="9-11">
							function area(s: Shape): number {
								switch (s.kind) {
									case "square":
										return s.size ** 2;
									case "rectangle":
										return s.height * s.width;
									case "circle":
										return Math.PI * s.radius ** 2;
									default:
									    throw new Error(`Unexpected obj:${s}`);
								}
							}	
					</code>
				</pre>
				<p>Należy rzucić wyjątek jeżeli zapomnieliśmy obsłużyć jakiejś opcji</p>
			</section>

			<section>
				<img src="img/compier_support.png" />
				<p>Typescript wie, że jakie mamy typy w <span class="hljs-variable">case</span>'ach' </p>
			</section>

			<section>
				<h2>A więc co zrobiliśmy?</h2>
				<ul>
					<li>Zbudowaliśmy abstrakcję na luźno, ze sobą powiązanych typach</li>
					<li>Rożnie zainterpretowaliśmy daną zmienną zależnie od kontesktu</li>
					<li>W tym wszystkim wsparł nas kompilator</li>
				</ul>
				<p class="fragment">Wzorzec ten jest również znany jako <strong
						style="text-decoration: underline">Algebraiczne typy
						danych, otagowane unie</strong> i jest często używany w <strong
						style="text-decoration: underline">funkcyjnym</strong> stylu programowania</p>
				</p>
			</section>
			<section>
				<h2>Co jeszcze typescript potrafi?</h2>
				<ul>
					<li class="fragment">Indeksowane typy</li>
					<li class="fragment">Mapowane typy</li>
					<li class="fragment">Uwarunkowane typy</li>
					<li class="fragment">I wiele więcej!</li>
				</ul>
			</section>

			<section>
				<h2>Dziękuję za uwagę</h2>
			</section>

			<section>
			</section>
			<section>
			</section>
			<section>
				<p>Sekretna porcja prezetancji jeżeli wystarczy na to czasu</p>
			</section>

			<section>
				<h2>Indeksowane typy</h2>
				<p>(index types)</p>
				<pre class="fragment">
						<code class="hljs typescript" data-trim data-noescape >
interface Person {
  name: string;
  age: number;
};
					</code>
					</pre>
				<pre class="fragment">
							<code class="hljs typescript" data-trim data-noescape >
const person: Person =  { name: 'Jarid', age: 35 };
						</code>
					</pre>
			</section>

			<section>
				<p>
					Checemy móć zdefinować funkcję get <span class="hljs-variable">getProperty(obj, key)</span>
				</p>
				<ul>
					<li class="fragment">Pozowli nam w bezpieczny, dynamiczny sposób pobrać pola tego obiektu</li>
					<li class="fragment"><strong>Zachowuję typ</strong> pobranego pola i nam go inferuję</li>
				</ul>

				<pre class="fragment">
						<code class="hljs typescript" data-trim data-noescape >
	let name: string = getProperty(person, 'name');
	let age: number = getProperty(person, 'age');
	let unknown = getProperty(person, 'unknown'); 
	//  ^^^^^^^ error, 'unknown' is not in 'name' | 'age'
					</code>
				</pre>
			</section>
			<section>
				<h2>Czy jest to możliwe?</h2>
				<div class="fragment">
					<p>Tak!</p>
					<pre class="">
						<code class="hljs typescript" data-trim>
function getProperty&lt;T, K extends keyof T>(
	o: T, 
	name: K
): T[K] {
	return o[name]; // o[name] is of type T[K]
}
					</code>
				</pre>
				</div>
			</section>

		</div>
	</div>

	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			hash: true,
			controls: true,
			progress: true,
			center: true,
			dependencies: [
				{ src: 'plugin/markdown/marked.js' },
				{ src: 'plugin/markdown/markdown.js' },
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/highlight/highlight.js', async: true }
			]
		});

		const fragEvents = {
			cbs: {},
			on(type, cb) {
				if (this.cbs[type] === undefined) {
					this.cbs[type] = [];
				}
				this.cbs[type].push(cb);
			},
			dispatch(type) {
				if (this.cbs[type] != undefined) {
					this.cbs[type].forEach(cb => cb());
				}
			}
		}

		Reveal.addEventListener('fragmentshown', function (ev) {
			const el = ev.fragment;
			if (el && el.getAttribute('data-show-event') != null) {
				const attr = el.getAttribute('data-show-event');
				fragEvents.dispatch(attr);
			}
		});

		fragEvents.on('RevealLuckyNumberType', function () {
			const el = document.getElementById('RevealLuckyNumberType-Code');
			el.style = 'transition: background 200ms ease-in';
			el.classList.add('flash-green-bg');
			setTimeout(() => el.classList.remove('flash-green-bg'), 200);
			el.innerHTML = 'let luckyNumber: 4 = 4;';
			hljs.initHighlighting();
		});

	</script>
</body>

</html>